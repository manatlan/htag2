{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"htag Documentation","text":"<p><code>htag</code> is a modern, state-of-the-art Python library for building interactive web applications using a declarative, component-based approach. It bridges the gap between Python and the browser by synchronizing state and events over WebSockets.</p> <p>View on GitHub</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Component-Based: Build complex UIs using reusable components via <code>Tag</code>.</li> <li>Pythonic &amp; Declarative: Write UI logic cleanly with <code>with</code> blocks (Context Managers).</li> <li>Reactive State: True zero-boilerplate <code>State</code> management (like React/SolidJS) in pure Python.</li> <li>Real-time: Automatic synchronization of UI changes via WebSockets.</li> <li>Responsive: Built-in support for multiple runners (Browser, Chrome App).</li> <li>Type-Safe: Comprehensive type hints for a great developer experience.</li> <li>Modern HTML: Native support for HTML5 void elements.</li> <li>Scoped Styles: Simple, robust CSS scoping via the <code>styles</code> attribute.</li> <li>Class Helpers: Convenient methods like <code>toggle_class()</code> and <code>has_class()</code>.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Creating a basic <code>htag</code> app is simple:</p> <pre><code>from htag import Tag, WebApp, State\n\n\nclass HelloApp(Tag.App):\n    def init(self) -&gt; None:\n        self.count = State(0)\n\n        with Tag.div(_class=\"container\"):\n            Tag.h1(\"Hello htag!\")\n            Tag.p(lambda: f\"Clicked {self.count.value} times\")\n            Tag.button(\"Click Me\", _onclick=self.increment)\n\n    def increment(self, e: Any) -&gt; None:\n        self.count.value += 1\n\nif __name__ == \"__main__\":\n    WebApp(HelloApp).run()\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ol> <li>Tag: The helper class to dynamically create UI components (e.g., <code>Tag.div()</code>, <code>Tag.input()</code>).</li> <li>App: A specialized tag (accessed via <code>Tag.App</code>) that acts as the root of your application and manages the server lifecycle.</li> <li>Runners: Classes like <code>WebApp</code> or <code>ChromeApp</code> that host and launch your application.</li> </ol> <p>Next: Components \u2192 | Reactivity &amp; State \u2192</p>"},{"location":"advanced/","title":"Advanced Features","text":"<p>Take your <code>htag</code> applications to the next level with these powerful features.</p>"},{"location":"advanced/#multi-session-support","title":"Multi-Session Support","text":"<p><code>htag</code> allows you to host unique application instances for different users using session cookies.</p>"},{"location":"advanced/#how-to-use-multi-session","title":"How to use Multi-Session","text":"<p>To enable multi-session isolation, you must pass the App class (not an instance) to your runner:</p> <pre><code>from htag import WebApp, Tag\n\nclass MyMultiUserApp(Tag.App):\n    def init(self) -&gt; None:\n        pass\n\nif __name__ == \"__main__\":\n    # Passing the CLASS enables session isolation\n    WebApp(MyMultiUserApp).run()\n</code></pre> <p>When a user visits the site, <code>htag</code> generates a unique session ID and creates a private instance of <code>MyMultiUserApp</code> for them.</p>"},{"location":"advanced/#session-request-integration","title":"Session &amp; Request Integration","text":"<p>When using <code>WebApp</code>, every tag has access to the current Starlette <code>Request</code> or <code>WebSocket</code> via the <code>self.request</code> property. This is updated on every interaction, allowing you to easily access or mutate the session:</p> <pre><code>class MyMultiUserApp(Tag.App):\n    def init(self) -&gt; None:\n        # Access the Starlette session directly!\n        username = self.request.session.get(\"user\", \"Guest\")\n        self &lt;= Tag.h2(f\"Welcome, {username}!\")\n\n    def on_click(self, e):\n        # Mutate the session\n        self.request.session[\"last_active\"] = \"just now\"\n</code></pre>"},{"location":"advanced/#global-statics-tagstatics","title":"Global Statics (<code>Tag.statics</code>)","text":"<p>You can bundle global dependencies, external CSS, and JavaScript with your components using the <code>statics</code> class attribute.</p> <p>[!TIP] For component-specific CSS, the Scoped Styles feature is usually preferred as it automatically handles CSS isolation securely.</p> <pre><code>class StyledComponent(Tag.div):\n    statics = [\n        Tag.style(\" .my-btn { color: lime; } \"),\n        Tag.link(_rel=\"stylesheet\", _href=\"https://cdn.example.com/styles.css\"),\n        Tag.script(_src=\"https://cdn.example.com/lib.js\")\n    ]\n</code></pre> <p><code>htag2</code> ensures that statics are:</p> <ul> <li>Collected recursively from all active tags, including those created dynamically via reactive lambdas.</li> <li>Sent to the client only once per session, regardless of how many instances of the component exist.</li> <li>Injected into the <code>&lt;head&gt;</code> dynamically if they are added after the initial load.</li> </ul>"},{"location":"advanced/#performance-best-practices","title":"Performance Best Practices","text":"<ol> <li>Partial Updates: <code>htag</code> only sends the HTML of \"dirty\" tags over the wire. Keep your components granular to minimize payload size.</li> <li>State Management: Use instance attributes on your components for local state. <code>htag</code> will automatically detect changes and queue re-renders.</li> <li>Thread Safety: <code>htag</code> components are thread-safe. You can modify the UI tree from background threads or async tasks safely.</li> </ol>"},{"location":"advanced/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Logs: Check the console logs. <code>htag</code> provides detailed INFO and DEBUG logs about sessions, WebSocket status, and event dispatching.</li> <li>WebSocket connection: Ensure your environment allows WebSocket connections (check firewalls/proxies). <code>htag</code> requires a constant WS link to function.</li> </ul> <p>\u2190 Runners</p>"},{"location":"components/","title":"Components","text":"<p>Components are the building blocks of an <code>htag</code> application. Every visual element is a <code>Tag</code> or a subclass of it.</p>"},{"location":"components/#tagdiv","title":"Tag.div","text":"<p><code>Tag.div</code> is the core class (the generic component). It handles HTML rendering, state management, and lifecycle.</p>"},{"location":"components/#creating-a-component","title":"Creating a Component","text":"<p>You can create a custom component by subclassing <code>Tag.div</code>, for example:</p> <pre><code>from htag import Tag\n\nclass MyComponent(Tag.div):\n    def init(self, name: str) -&gt; None:\n        self._class = \"my-class\"\n        self.add(f\"Hello {name}!\")\n</code></pre>"},{"location":"components/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Lifecycle hooks let you run code at specific times in a component's life:</p> <ul> <li><code>init(*args, **kwargs)</code>: Called exactly once at the end of component initialization. Use this instead of overriding <code>__init__</code> to avoid <code>super()</code> boilerplates.</li> <li><code>on_mount()</code>: Called when the component is attached to the application DOM tree. Use this for subscribing to events or initializing resources that need a live DOM. Good for subscribing to events or doing initial fetches.</li> <li><code>on_unmount(self)</code>: Called when the component (or its parent) is removed from the <code>Tag.App</code>. Good for cleaning up tasks or event listeners.</li> </ul> <pre><code>class Clock(Tag.div):\n    def init(self) -&gt; None:\n        self._class = \"clock\"\n        self.taskId: int | None = None\n\n    def on_mount(self) -&gt; None:\n        # We are on the screen! Start ticking...\n        print(\"Clock mounted\")\n\n    def on_unmount(self) -&gt; None:\n        # We are removed from the screen! Cleanup...\n        print(\"Clock unmounted\")\n</code></pre>"},{"location":"components/#tree-manipulation","title":"Tree Manipulation","text":"<ul> <li><code>self.add(*content)</code>: Adds children (strings or other components).</li> <li><code>self &lt;= content</code>: An elegant shorthand for <code>self.add(content)</code>.</li> <li><code>self.remove(child)</code>: Removes a child.</li> <li><code>self.clear()</code>: Removes all children.</li> <li><code>self.remove_self()</code>: Removes the component from its parent.</li> <li><code>self.root</code>: Returns the <code>Tag.App</code> instance this component belongs to (or <code>None</code> if unattached).</li> <li><code>self.parent</code>: Returns the parent <code>GTag</code> instance (or <code>None</code> if unattached).</li> <li><code>self.childs</code>: A list of the component's children (strings or other <code>GTag</code> instances).</li> </ul> <pre><code># Using the &lt;= operator\nrow = Tag.div()\nrow &lt;= Tag.span(\"Left\")\nrow &lt;= Tag.span(\"Right\")\n</code></pre>"},{"location":"components/#declarative-ui-context-managers","title":"Declarative UI (Context Managers)","text":"<p>The preferred way to build complex component trees is using the <code>with</code> statement. New tags created inside a <code>with</code> block are automatically appended to the parent tag.</p> <pre><code>with Tag.div(_class=\"card\"):\n    Tag.h2(\"Title\")\n    with Tag.div(_class=\"content\"):\n        Tag.p(\"This is automatically added to the content div.\")\n</code></pre>"},{"location":"components/#rapid-content-replacement-text","title":"Rapid Content Replacement (<code>.text</code>)","text":"<p>Use the <code>.text</code> property to quickly replace all children of a tag with a single string. This is more efficient for simple text updates.</p> <pre><code>self.label.text = \"Status: OK\"\n</code></pre>"},{"location":"components/#attributes-and-style","title":"Attributes and Style","text":"<p>Attributes are managed using properties starting with an underscore. This mapping covers all standard and custom HTML attributes.</p> <pre><code># Mapping attributes\nimg = Tag.img(_src=\"/logo.png\", _alt=\"Logo\")\nimg._width = \"100\"\n\n# Custom data attributes\ndiv = Tag.div(_data_user_id=\"123\")\n</code></pre> <ul> <li><code>_class</code>: Maps to the <code>class</code> attribute.</li> <li><code>_id</code>: Maps to the <code>id</code> attribute.</li> <li><code>_style</code>: Maps to the <code>style</code> attribute.</li> <li><code>_any_thing</code>: Maps to <code>any-thing</code> in the rendered HTML.</li> </ul>"},{"location":"components/#css-class-helpers","title":"CSS Class Helpers","text":"<p>Convenience methods for manipulating CSS classes:</p> <pre><code>tag.add_class(\"active\")       # add if not present\ntag.remove_class(\"active\")    # remove if present\ntag.toggle_class(\"hidden\")    # add or remove\ntag.has_class(\"active\")       # returns bool\n</code></pre> <p>All mutating methods return <code>self</code> for chaining and only mark the component dirty if the class list actually changed.</p>"},{"location":"components/#scoped-styles","title":"Scoped Styles","text":"<p>Use the <code>styles</code> class attribute to define CSS that is automatically scoped to the component:</p> <pre><code>class MyCard(Tag.div):\n    styles = \"\"\"\n        .title { color: #1e40af; font-weight: bold; }\n        .content { padding: 16px; border: 1px solid #e2e8f0; }\n    \"\"\"\n    def init(self, title):\n        self &lt;= Tag.h2(title, _class=\"title\")\n        self &lt;= Tag.p(\"No style leaking!\", _class=\"content\")\n</code></pre> <p>The framework generates scoped selectors (e.g., <code>.htag-MyCard .title</code>) and automatically adds the <code>htag-MyCard</code> class to the root element after the <code>init()</code> call, ensuring it's not accidentally overwritten.</p> <p>Every rule in <code>styles</code> is transformed to match both the element itself and its descendants. For example, <code>.title</code> becomes <code>.htag-MyCard.title, .htag-MyCard .title</code>. It also handles tag selectors correctly (e.g., <code>div</code> becomes <code>div.htag-MyCard, .htag-MyCard div</code>).</p> <p>Supported CSS features: - <code>@media</code> (inner rules are recursively scoped) - <code>@keyframes</code> (passed through unchanged to avoid breaking animations) - Pseudo-selectors (<code>:hover</code>, <code>::before</code>, <code>:nth-child</code>, etc.) - Comma-separated selectors and all combinators (<code>&gt;</code>, <code>+</code>, <code>~</code>, spaces)</p> <p>[!NOTE] <code>styles</code> is declarative (processed once at class level). For dynamic styling during interactions, use <code>_style</code>, <code>_class</code>, or <code>toggle_class()</code>.</p>"},{"location":"components/#the-tag-creator","title":"The Tag Creator","text":"<p>The <code>Tag</code> singleton allows you to create standard HTML elements dynamically using a clean syntax:</p> <pre><code>from htag import Tag\n\n# Equivalent to &lt;div class=\"foo\"&gt;content&lt;/div&gt;\nd = Tag.div(\"content\", _class=\"foo\")\n\n# Equivalent to &lt;br/&gt; (Void Element)\nb = Tag.br()\n\n# Equivalent to &lt;input type=\"text\" value=\"hello\"/&gt;\ni = Tag.input(_type=\"text\", _value=\"hello\")\n</code></pre>"},{"location":"components/#void-elements","title":"Void Elements","text":"<p><code>htag</code> automatically handles HTML void elements (self-closing tags) like <code>input</code>, <code>img</code>, <code>br</code>, <code>hr</code>, etc. You don't need to specify a closing tag for these.</p> <p>\u2190 Home | Next: Events \u2192</p>"},{"location":"deployment/","title":"Production Deployment","text":"<p>While runners are great for development and desktop apps, <code>htag</code> applications are fully compatible with production-grade web servers.</p>"},{"location":"deployment/#starlette-integration","title":"Starlette Integration","text":"<p>Every <code>Tag.App</code> in <code>htag</code> exposes an underlying Starlette instance through its <code>.app</code> property. This allows you to deploy your application using standard tools like <code>uvicorn</code> or <code>gunicorn</code>.</p>"},{"location":"deployment/#basic-production-entrypoint","title":"Basic Production Entrypoint","text":"<pre><code># app.py\nfrom htag import Tag\n\nclass MyApp(Tag.App):\n    def init(self):\n        self &lt;= Tag.h1(\"Production App\")\n\n# Create the WebApp runner (production: debug=False)\nfrom htag.server import WebApp\napp = WebApp(MyApp, debug=False).app\n</code></pre> <p>You can now run this with <code>uvicorn</code>:</p> <pre><code>uvicorn app:app --host 0.0.0.0 --port 80\n</code></pre>"},{"location":"deployment/#embedding-htag-in-existing-starlettefastapi-apps","title":"Embedding htag in existing Starlette/FastAPI apps","text":"<p>Since <code>htag</code> uses a <code>WebApp</code> wrapper, you can also mount it as a sub-application or include its routes in a larger Starlette or FastAPI project.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom htag.server import WebApp\nfrom my_htag_app import MyApp\n\nmain_app = Starlette()\n\n# Wrap your htag App in a WebApp\nhtag_app = WebApp(MyApp)\n\n# Mount or include routes\nmain_app.mount(\"/htag\", htag_app.app)\n\n@main_app.route(\"/health\")\ndef health(request):\n    return JSONResponse({\"status\": \"ok\"})\n</code></pre>"},{"location":"deployment/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>WebSockets: Ensure your production load balancer (like Nginx or Traefik) is configured to handle WebSocket connections properly.</li> <li>Workers: Since <code>htag</code> maintains session state in memory (by default), you should ideally use sticky sessions if you scale to multiple worker processes or containers.</li> <li>Memory: Each active session consumes a small amount of memory on the server. Monitor your memory usage if you expect thousands of concurrent users.</li> </ul> <p>\u2190 Runners | Home</p>"},{"location":"events/","title":"Events and Reactivity","text":"<p><code>htag</code> provides a seamless way to handle user interactions on the server side.</p>"},{"location":"events/#event-handlers","title":"Event Handlers","text":"<p>You can attach event handlers to any <code>Tag</code> component using the <code>_on{event}</code> syntax:</p> <pre><code>def my_callback(e: Any) -&gt; None:\n    print(f\"Clicked on {e.target.id}\")\n    e.target.add(Tag.span(\"!\"))\n\nbtn = Tag.button(\"Click me\", _onclick=my_callback)\n</code></pre>"},{"location":"events/#the-event-object","title":"The Event Object","text":"<p>The <code>e</code> argument passed to the callback is an <code>Event</code> object containing:</p> <ul> <li><code>e.target</code>: The <code>Tag</code> instance that triggered the event.</li> <li><code>e.name</code>: The name of the event (e.g., \"click\").</li> <li>Data attributes like <code>e.value</code> (for inputs), <code>e.x</code>, <code>e.y</code> (for mouse events), etc.</li> </ul>"},{"location":"events/#automatic-binding-magic-bind","title":"Automatic Binding (Magic Bind)","text":"<p><code>htag</code> automatically synchronizes the state of input elements without requiring explicit event handlers.</p> <p>When you use an <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, or <code>&lt;select&gt;</code>, <code>htag</code> injects an <code>_oninput</code> event that updates the component's <code>_value</code> attribute in real-time on the server.</p> <pre><code>class MyForm(Tag.App):\n    def init(self) -&gt; None:\n        # No '_oninput' needed, it's automatic!\n        self.entry = Tag.input(_value=\"Initial\")\n        self &lt;= self.entry\n        self &lt;= Tag.button(\"Show\", _onclick=lambda e: self.add(f\"Value is: {self.entry._value}\"))\n</code></pre>"},{"location":"events/#async-handlers","title":"Async Handlers","text":"<p><code>htag</code> fully supports <code>asyncio</code>. You can define callbacks as <code>async def</code>:</p> <pre><code>async def my_async_callback(e: Any) -&gt; None:\n    await asyncio.sleep(1)\n    e.target.add(\"Done!\")\n</code></pre>"},{"location":"events/#ui-streaming-generators","title":"UI Streaming (Generators)","text":"<p>For long-running tasks that need to update the UI multiple times, you can use generators:</p> <pre><code>def my_generator(e: Any) -&gt; Generator:\n    e.target.add(\"Starting...\")\n    yield # Triggers a UI update to the client\n\n    import time\n    time.sleep(2)\n    e.target.add(\"Halfway...\")\n    yield\n\n    time.sleep(2)\n    e.target.add(\"Finished!\")\n\n### Async Generators\n\nhtag2 also supports `async for` generators for asynchronous UI streaming.\n\n```python\nasync def my_async_gen(e: Any) -&gt; AsyncGenerator:\n    e.target.add(\"Fetching...\")\n    yield\n    await asyncio.sleep(2)\n    e.target.add(\"Data ready!\")\n</code></pre> <p>[!TIP] Use generators for any operation that takes more than 100ms to keep the UI responsive and provide feedback to the user. <pre><code>## Event Decorators\n\n- `@prevent`: Calls `event.preventDefault()` in the browser.\n- `@stop`: Calls `event.stopPropagation()` in the browser.\n\n```python\nfrom htag import prevent, stop\n\n@prevent\ndef handle_submit(e):\n    # Form won't reload the page\n    pass\n</code></pre></p>"},{"location":"events/#client-side-javascript","title":"Client-side JavaScript","text":"<p>You can execute arbitrary JavaScript from the server using <code>call_js()</code>:</p> <pre><code>class MyTag(Tag.div):\n    def boom(self, e):\n        self.call_js(\"alert('BOOM!')\")\n</code></pre> <p>\u2190 Components | Reactivity &amp; State \u2192 | Next: Runners \u2192</p>"},{"location":"reactivity/","title":"Reactivity and State","text":"<p>htag2 features a powerful, zero-boilerplate reactivity system inspired by modern web frameworks. It allows you to build data-driven UIs where components update automatically as your data changes.</p>"},{"location":"reactivity/#the-state-object","title":"The State Object","text":"<p>The <code>State</code> class is the heart of the reactivity system. It tracks dependencies and notifies components when values change.</p> <pre><code>from htag import Tag, State\n\nclass MyApp(Tag.App):\n    def init(self) -&gt; None:\n        self.count = State(0)\n</code></pre>"},{"location":"reactivity/#functional-updates-with-set","title":"Functional Updates with <code>.set()</code>","text":"<p>When updating state within a lambda (e.g., in an event callback), use <code>state.set(new_value)</code>. This updates the state and returns the new value.</p> <pre><code>Tag.button(\"+1\", _onclick=lambda e: self.count.set(self.count.value + 1))\n</code></pre>"},{"location":"reactivity/#mutable-values-with-notify","title":"Mutable Values with <code>.notify()</code>","text":"<p>When mutating a value in-place (e.g., appending to a list), the <code>State</code> can't detect the change automatically. Call <code>.notify()</code> to force observers to update:</p> <pre><code>self.items = State([\"a\", \"b\"])\n\ndef add_item(e):\n    self.items.value.append(\"c\")\n    self.items.notify()  # triggers re-render\n</code></pre>"},{"location":"reactivity/#reactive-children","title":"Reactive Children","text":"<p>You can pass a lambda as a child to any tag. htag2 will automatically track which <code>State</code> objects are accessed during the lambda's execution and will re-render just that part of the UI when the state changes.</p> <pre><code># The text will update automatically whenever self.count changes\nTag.p(lambda: f\"The current count is {self.count.value}\")\n</code></pre>"},{"location":"reactivity/#lists-of-components","title":"Lists of Components","text":"<p>Lambdas can also return lists or tuples of components. htag2 handles the flattening and rendering automatically.</p> <pre><code>Tag.ul(lambda: [Tag.li(user.name) for user in self.users.value])\n</code></pre>"},{"location":"reactivity/#reactive-boolean-attributes","title":"Reactive &amp; Boolean Attributes","text":"<p>Attributes can also be reactive by passing a lambda.</p>"},{"location":"reactivity/#dynamic-classes-and-styles","title":"Dynamic Classes and Styles","text":"<pre><code>Tag.div(\n    _class=lambda: \"text-red-600\" if self.error.value else \"text-green-600\",\n    _style=lambda: f\"opacity: {self.opacity.value}%\"\n)\n</code></pre>"},{"location":"reactivity/#boolean-attributes","title":"Boolean Attributes","text":"<p>htag2 handles boolean attributes (like <code>disabled</code>, <code>checked</code>, <code>required</code>, <code>readonly</code>) intelligently:</p> <ul> <li>True: Renders the attribute name only (e.g., <code>&lt;button disabled&gt;</code>).</li> <li>False / None: Omit the attribute entirely (e.g., <code>&lt;button&gt;</code>).</li> <li>Lambda: Can return <code>True</code>, <code>False</code>, or <code>None</code> for dynamic control.</li> </ul> <pre><code>Tag.button(\"Submit\", _disabled=lambda: self.is_loading.value)\n</code></pre>"},{"location":"reactivity/#how-it-works","title":"How it Works","text":"<ol> <li>Dependency Tracking: When a reactive lambda is executed, htag2 records which <code>State</code> objects were read.</li> <li>Notification: When a <code>State</code> value is modified, it notifies all recorded components (\"observers\").</li> <li>Selective Re-rendering: The framework re-renders only the necessary components and sends the minimal HTML delta to the browser over WebSockets.</li> </ol>"},{"location":"runners/","title":"Runners","text":"<p>Runners are responsible for hosting your <code>App</code> and launching the interface.</p>"},{"location":"runners/#web-deployment-starlette-integration","title":"Web Deployment (Starlette Integration)","text":"<p>For web-based deployment, we recommend integrating your <code>htag2</code> application directly into a Starlette (or FastAPI) server. This provides the most flexibility and follows standard Python web practices.</p> <pre><code>from htag import Tag\nfrom starlette.applications import Starlette\nimport uvicorn\n\nclass MyApp(Tag.App):\n    def init(self):\n        self &lt;= Tag.h1(\"I am a web app\")\n\n# 1. Create your main Starlette/FastAPI app\napp = Starlette(debug=False)  # Starlette's own debug mode\n\n# 2. Wrap your htag app in a WebApp runner\nfrom htag import WebApp\n# Wrap your htag App in a WebApp\nhtag_app = WebApp(MyApp)\n\n# Mount or include routes\napp.mount(\"/htag\", htag_app.app)\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <ul> <li>Advantages: <ul> <li>Full control over routes, middleware, and documentation.</li> <li>Seamlessly mix standard HTML/API routes with reactive <code>htag2</code> components.</li> <li>Support for subpath mounting (e.g., <code>app.mount(\"/app\", ...)</code>).</li> </ul> </li> </ul>"},{"location":"runners/#desktop-deployment-chromeapp","title":"Desktop Deployment (ChromeApp)","text":"<p><code>ChromeApp</code> is the primary runner for local desktop usage. It attempts to launch a clean desktop-like Kiosk window via Chromium/Chrome binaries.</p> <pre><code>from htag import ChromeApp, Tag\n\nclass MyApp(Tag.App):\n    pass\n\nif __name__ == \"__main__\":\n    # debug=True (default) enables browser-side error reporting\n    ChromeApp(MyApp, width=600, height=800, debug=True).run()\n</code></pre> <ul> <li>Features:<ul> <li>Clean UI without URL bars or browser tabs.</li> <li>Automatic cleanup of temporary browser profiles.</li> <li>Smart Exit: Automatically shuts down the Python server when the window is closed.</li> </ul> </li> </ul>"},{"location":"runners/#development-hot-reload-dx","title":"Development &amp; Hot-Reload (DX)","text":"<p>For an improved Developer Experience (DX), you can pass <code>reload=True</code> to the runner during development:</p> <pre><code>if __name__ == \"__main__\":\n    from htag import ChromeApp\n    ChromeApp(MyApp).run(reload=True) \n</code></pre> <p>When <code>reload=True</code> is provided: 1. Zero-Config File Watcher: <code>htag2</code> spawns a master process that watches all <code>.py</code> files in your current directory recursively. 2. Auto-Restart: When you save a file, the Python ASGI backend is instantly terminated and restarted with your new code. 3. Seamless Browser Refresh: The UI frontend stays open. It will realize the backend went offline, automatically poll for reconnection, and gracefully refresh the window once the new backend is up.</p> <p>\u2190 Events | Next: Advanced \u2192</p>"}]}